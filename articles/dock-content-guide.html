<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Document and Tool Content Guide | Dock for Avalonia </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Document and Tool Content Guide | Dock for Avalonia ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/wieslawsoltes/Dock/blob/master/docfx/articles/dock-content-guide.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="document-and-tool-content-guide">Document and Tool Content Guide</h1>

<p>This guide explains how to add actual content to your documents and tools in the Dock framework, addressing the most common questions about content setup.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#understanding-content-in-dock">Understanding Content in Dock</a></li>
<li><a href="#method-1-itemssource-collection-binding-recommended">Method 1: ItemsSource Collection Binding (Recommended)</a></li>
<li><a href="#method-2-viewmodel--datatemplate-pattern">Method 2: ViewModel + DataTemplate Pattern</a></li>
<li><a href="#method-3-function-based-content">Method 3: Function-Based Content</a></li>
<li><a href="#method-4-direct-xaml-content">Method 4: Direct XAML Content</a></li>
<li><a href="#working-with-tools">Working with Tools</a></li>
<li><a href="#common-issues-and-troubleshooting">Common Issues and Troubleshooting</a></li>
<li><a href="#complete-examples">Complete Examples</a></li>
</ul>
<h2 id="prerequisites">Prerequisites</h2>
<p>Make sure you have the required NuGet packages installed:</p>
<pre><code class="lang-xml">&lt;PackageReference Include=&quot;Dock.Avalonia&quot; /&gt;
&lt;PackageReference Include=&quot;Dock.Model.Avalonia&quot; /&gt;
&lt;PackageReference Include=&quot;Dock.Avalonia.Themes.Fluent&quot; /&gt;
</code></pre>
<p>Examples below use <code>RelayCommand</code> from <code>CommunityToolkit.Mvvm.Input</code>. Use your own <code>ICommand</code> implementation if you prefer a different MVVM toolkit.</p>
<p>If you want MVVM-style base classes with <code>SetProperty</code>, install the matching model package (for example <code>Dock.Model.Mvvm</code>, <code>Dock.Model.ReactiveUI</code>, or <code>Dock.Model.CaliburMicro</code>) and use those <code>Document</code>/<code>Tool</code> base types in the examples.</p>
<p>For XAML usage, you need these namespace declarations:</p>
<pre><code class="lang-xaml">xmlns:dock=&quot;using:Dock.Model.Avalonia.Controls&quot;
xmlns:dockCore=&quot;using:Dock.Model.Core&quot;
</code></pre>
<h2 id="understanding-content-in-dock">Understanding Content in Dock</h2>
<p>The Dock framework supports four main approaches for defining content:</p>
<ol>
<li><strong>ItemsSource Collection Binding</strong>: Bind collections directly to DocumentDock for automatic document management</li>
<li><strong>ViewModel + DataTemplate</strong>: Use view models and let Avalonia's data template system resolve views</li>
<li><strong>Function-Based</strong>: Provide a function that creates the content control</li>
<li><strong>Direct XAML</strong>: Define content directly in XAML (XAML-only approach)</li>
</ol>
<h2 id="method-1-itemssource-collection-binding-recommended">Method 1: ItemsSource Collection Binding (Recommended)</h2>
<p>DocumentDock supports automatic document creation from collections using the <code>ItemsSource</code> property, similar to how <code>ItemsControl</code> works in Avalonia. This is the recommended approach for most scenarios and is available in the Avalonia model (<code>Dock.Model.Avalonia.Controls.DocumentDock</code>).</p>
<h3 id="when-to-use-this-approach">When to Use This Approach</h3>
<p>This is ideal when you:</p>
<ul>
<li>Have a collection of domain objects that should each become a document</li>
<li>Want automatic document creation/removal based on collection changes</li>
<li>Prefer declarative XAML setup over manual document management</li>
<li>Need to bind to existing business objects without creating wrapper ViewModels</li>
</ul>
<h3 id="step-1-define-your-document-model">Step 1: Define Your Document Model</h3>
<pre><code class="lang-csharp">public class MyDocumentModel : INotifyPropertyChanged
{
    private string _title = &quot;&quot;;
    private string _content = &quot;&quot;;
    private bool _canClose = true;

    public string Title
    {
        get =&gt; _title;
        set =&gt; SetProperty(ref _title, value);
    }

    public string Content
    {
        get =&gt; _content;
        set =&gt; SetProperty(ref _content, value);
    }

    public bool CanClose
    {
        get =&gt; _canClose;
        set =&gt; SetProperty(ref _canClose, value);
    }

    // INotifyPropertyChanged implementation...
    public event PropertyChangedEventHandler? PropertyChanged;
    protected bool SetProperty&lt;T&gt;(ref T field, T value, [CallerMemberName] string propertyName = &quot;&quot;)
    {
        if (EqualityComparer&lt;T&gt;.Default.Equals(field, value)) return false;
        field = value;
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        return true;
    }
}
</code></pre>
<h3 id="step-2-set-up-your-viewmodel-with-a-collection">Step 2: Set Up Your ViewModel with a Collection</h3>
<p>The examples below use <code>RelayCommand</code> from <code>CommunityToolkit.Mvvm.Input</code>. Replace it with any <code>ICommand</code> implementation you prefer.</p>
<pre><code class="lang-csharp">public class MainViewModel : INotifyPropertyChanged
{
    public ObservableCollection&lt;MyDocumentModel&gt; Documents { get; } = new();

    public ICommand AddDocumentCommand { get; }
    public ICommand RemoveDocumentCommand { get; }
    public ICommand ClearAllCommand { get; }

    public MainViewModel()
    {
        // Add some initial documents
        Documents.Add(new MyDocumentModel 
        { 
            Title = &quot;Welcome&quot;, 
            Content = &quot;Welcome to the ItemsSource example!&quot; 
        });
        Documents.Add(new MyDocumentModel 
        { 
            Title = &quot;Documentation&quot;, 
            Content = &quot;This demonstrates automatic document creation from a collection.&quot; 
        });

        AddDocumentCommand = new RelayCommand(AddNewDocument);
        RemoveDocumentCommand = new RelayCommand(RemoveLastDocument, () =&gt; Documents.Count &gt; 0);
        ClearAllCommand = new RelayCommand(ClearAllDocuments, () =&gt; Documents.Count &gt; 0);
    }

    private void AddNewDocument()
    {
        Documents.Add(new MyDocumentModel
        {
            Title = $&quot;Document {Documents.Count + 1}&quot;,
            Content = $&quot;This is document number {Documents.Count + 1}&quot;,
            CanClose = true
        });
    }

    private void RemoveLastDocument()
    {
        if (Documents.Count &gt; 0)
            Documents.RemoveAt(Documents.Count - 1);
    }

    private void ClearAllDocuments()
    {
        Documents.Clear();
    }
}
</code></pre>
<h3 id="step-3-bind-to-documentdock-in-xaml">Step 3: Bind to DocumentDock in XAML</h3>
<pre><code class="lang-xaml">&lt;UserControl xmlns=&quot;https://github.com/avaloniaui&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
             xmlns:local=&quot;using:YourApp&quot;
             x:Class=&quot;YourApp.ItemsSourceExample&quot;&gt;

  &lt;UserControl.DataContext&gt;
    &lt;local:MainViewModel /&gt;
  &lt;/UserControl.DataContext&gt;

  &lt;Grid RowDefinitions=&quot;Auto,*&quot;&gt;
    &lt;!-- Controls to add/remove items --&gt;
    &lt;StackPanel Grid.Row=&quot;0&quot; Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt;
      &lt;Button Content=&quot;Add Document&quot; Command=&quot;{Binding AddDocumentCommand}&quot; Margin=&quot;0,0,5,0&quot; /&gt;
      &lt;Button Content=&quot;Remove Document&quot; Command=&quot;{Binding RemoveDocumentCommand}&quot; Margin=&quot;0,0,5,0&quot; /&gt;
      &lt;Button Content=&quot;Clear All&quot; Command=&quot;{Binding ClearAllCommand}&quot; /&gt;
    &lt;/StackPanel&gt;

    &lt;DockControl Grid.Row=&quot;1&quot; InitializeLayout=&quot;True&quot; InitializeFactory=&quot;True&quot;&gt;
      &lt;DockControl.Factory&gt;
        &lt;Factory /&gt;
      &lt;/DockControl.Factory&gt;

      &lt;RootDock Id=&quot;Root&quot; IsCollapsable=&quot;False&quot;&gt;
        &lt;DocumentDock Id=&quot;DocumentsPane&quot; 
                      CanCreateDocument=&quot;True&quot;
                      ItemsSource=&quot;{Binding Documents}&quot;&gt;
          
          &lt;!-- Define how each document should be displayed --&gt;
          &lt;DocumentDock.DocumentTemplate&gt;
            &lt;DocumentTemplate&gt;
              &lt;StackPanel Margin=&quot;10&quot; x:DataType=&quot;Document&quot;&gt;
                &lt;TextBlock Text=&quot;Document Title:&quot; FontWeight=&quot;Bold&quot;/&gt;
                &lt;TextBox Text=&quot;{Binding Title}&quot; Margin=&quot;0,0,0,10&quot;/&gt;
                &lt;TextBlock Text=&quot;Content:&quot; FontWeight=&quot;Bold&quot;/&gt;
                &lt;TextBox Text=&quot;{Binding Context.Content}&quot; AcceptsReturn=&quot;True&quot; Height=&quot;200&quot; TextWrapping=&quot;Wrap&quot;/&gt;
              &lt;/StackPanel&gt;
            &lt;/DocumentTemplate&gt;
          &lt;/DocumentDock.DocumentTemplate&gt;
          
        &lt;/DocumentDock&gt;
      &lt;/RootDock&gt;
    &lt;/DockControl&gt;
  &lt;/Grid&gt;
&lt;/UserControl&gt;
</code></pre>
<h3 id="how-it-works">How It Works</h3>
<ol>
<li><strong>Automatic Document Creation</strong>: Each item in the collection becomes a <code>Document</code> instance</li>
<li><strong>Collection Change Monitoring</strong>: Adding/removing items automatically adds/removes documents</li>
<li><strong>DocumentTemplate</strong>: Used to create the visual content for each document</li>
<li><strong>Property Mapping</strong>: Document properties are automatically mapped from your model:
<ul>
<li><code>Title</code> → Document title</li>
<li><code>Name</code> → Alternative for title</li>
<li><code>DisplayName</code> → Alternative for title</li>
<li><code>CanClose</code> → Whether the document can be closed</li>
</ul>
</li>
<li><strong>Data Context</strong>: Your model object becomes the <code>Context</code> of the created Document and is accessible via <code>{Binding Context.PropertyName}</code></li>
</ol>
<h3 id="advanced-examples">Advanced Examples</h3>
<h4 id="custom-title-and-canclose-mapping">Custom Title and CanClose Mapping</h4>
<p>The system automatically looks for common property names:</p>
<pre><code class="lang-csharp">public class FileModel
{
    public string Name { get; set; } = &quot;&quot;;        // Used for document title
    public string Path { get; set; } = &quot;&quot;;
    public bool IsReadOnly { get; set; }
    public bool CanClose =&gt; !IsReadOnly;          // Controls if document can be closed
}
</code></pre>
<h4 id="with-commands-and-interactions">With Commands and Interactions</h4>
<pre><code class="lang-xaml">&lt;DocumentDock ItemsSource=&quot;{Binding OpenFiles}&quot;&gt;
  &lt;DocumentDock.DocumentTemplate&gt;
    &lt;DocumentTemplate&gt;
      &lt;Grid RowDefinitions=&quot;Auto,*,Auto&quot; x:DataType=&quot;Document&quot;&gt;
        &lt;TextBlock Grid.Row=&quot;0&quot; Text=&quot;{Binding Context.Path}&quot; FontSize=&quot;12&quot; Opacity=&quot;0.7&quot;/&gt;
        &lt;TextBox Grid.Row=&quot;1&quot; Text=&quot;{Binding Context.Content}&quot; AcceptsReturn=&quot;True&quot;/&gt;
        &lt;StackPanel Grid.Row=&quot;2&quot; Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Right&quot;&gt;
          &lt;Button Content=&quot;Save&quot; Command=&quot;{Binding Context.SaveCommand}&quot; Margin=&quot;5&quot;/&gt;
          &lt;Button Content=&quot;Revert&quot; Command=&quot;{Binding Context.RevertCommand}&quot; Margin=&quot;5&quot;/&gt;
        &lt;/StackPanel&gt;
      &lt;/Grid&gt;
    &lt;/DocumentTemplate&gt;
  &lt;/DocumentDock.DocumentTemplate&gt;
&lt;/DocumentDock&gt;
</code></pre>
<h3 id="benefits">Benefits</h3>
<ul>
<li><strong>Automatic Synchronization</strong>: Collection changes instantly reflect in the UI</li>
<li><strong>Clean Separation</strong>: Keep your business models separate from UI infrastructure</li>
<li><strong>MVVM Friendly</strong>: Natural binding to your existing ViewModels</li>
<li><strong>Less Boilerplate</strong>: No need to manually manage document creation/removal</li>
<li><strong>Production Ready</strong>: Fully implemented and tested functionality</li>
</ul>
<h2 id="method-2-viewmodel--datatemplate-pattern">Method 2: ViewModel + DataTemplate Pattern</h2>
<p>This approach follows MVVM principles and provides the best flexibility for complex scenarios.</p>
<h3 id="step-1-create-a-document-viewmodel">Step 1: Create a Document ViewModel</h3>
<pre><code class="lang-csharp">using Dock.Model.Mvvm.Controls;

namespace YourApp.ViewModels.Documents;

public class TextDocumentViewModel : Document
{
    private string _text = &quot;&quot;;
    
    public TextDocumentViewModel()
    {
        Id = Guid.NewGuid().ToString();
        Title = &quot;New Document&quot;;
        CanClose = true;
    }

    public string Text
    {
        get =&gt; _text;
        set =&gt; SetProperty(ref _text, value);
    }
}
</code></pre>
<h3 id="step-2-create-the-view">Step 2: Create the View</h3>
<pre><code class="lang-xaml">&lt;!-- Views/Documents/TextDocumentView.axaml --&gt;
&lt;UserControl xmlns=&quot;https://github.com/avaloniaui&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
             xmlns:vm=&quot;using:YourApp.ViewModels.Documents&quot;
             x:Class=&quot;YourApp.Views.Documents.TextDocumentView&quot;
             x:DataType=&quot;vm:TextDocumentViewModel&quot;&gt;

  &lt;Grid RowDefinitions=&quot;Auto,*&quot;&gt;
    &lt;TextBlock Grid.Row=&quot;0&quot; Text=&quot;{Binding Title}&quot; FontWeight=&quot;Bold&quot; Margin=&quot;5&quot;/&gt;
    &lt;TextBox Grid.Row=&quot;1&quot; Text=&quot;{Binding Text}&quot; AcceptsReturn=&quot;True&quot; Margin=&quot;5&quot;/&gt;
  &lt;/Grid&gt;

&lt;/UserControl&gt;
</code></pre>
<h3 id="step-3-register-datatemplate-in-appaxaml">Step 3: Register DataTemplate in App.axaml</h3>
<pre><code class="lang-xaml">&lt;Application xmlns=&quot;https://github.com/avaloniaui&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
             xmlns:vm=&quot;using:YourApp.ViewModels.Documents&quot;
             xmlns:views=&quot;using:YourApp.Views.Documents&quot;
             x:Class=&quot;YourApp.App&quot;&gt;

  &lt;Application.DataTemplates&gt;
    &lt;DataTemplate DataType=&quot;{x:Type vm:TextDocumentViewModel}&quot;&gt;
      &lt;views:TextDocumentView /&gt;
    &lt;/DataTemplate&gt;
  &lt;/Application.DataTemplates&gt;

&lt;/Application&gt;
</code></pre>
<h3 id="step-4-add-documents-programmatically">Step 4: Add Documents Programmatically</h3>
<pre><code class="lang-csharp">private void AddNewDocument()
{
    var existing = DocumentsPane.VisibleDockables
        ?.OfType&lt;TextDocumentViewModel&gt;()
        ?.FirstOrDefault(d =&gt; d.Id == &quot;specific-id&quot;);
    
    if (existing != null)
    {
        DocumentsPane.ActiveDockable = existing;
        return;
    }

    // Create the document view model
    var document = new TextDocumentViewModel
    {
        Title = &quot;My Document&quot;,
        Text = &quot;Initial content&quot;
    };

    // Add to dock
    _factory?.AddDockable(DocumentsPane, document);
    _factory?.SetActiveDockable(document);
    _factory?.SetFocusedDockable(DocumentsPane, document);
}
</code></pre>
<h2 id="method-3-function-based-content">Method 3: Function-Based Content</h2>
<p>If you need to create views dynamically or integrate with dependency injection:</p>
<pre><code class="lang-csharp">private void AddDocumentWithFunction()
{
    var document = new Document
    {
        Id = Guid.NewGuid().ToString(),
        Title = &quot;Function Document&quot;,
        CanClose = true,
        // Content is a function that creates the view
        Content = new Func&lt;IServiceProvider, object&gt;(_ =&gt; 
        {
            // You can use DI container here if needed
            var view = new TextDocumentView();
            view.DataContext = new TextDocumentViewModel { Text = &quot;Hello World&quot; };
            return view;
        })
    };

    _factory?.AddDockable(DocumentsPane, document);
    _factory?.SetActiveDockable(document);
}
</code></pre>
<h2 id="method-4-direct-xaml-content">Method 4: Direct XAML Content</h2>
<p>For simple static content, you can define it directly in XAML:</p>
<pre><code class="lang-xaml">&lt;dock:DocumentDock x:Name=&quot;DocumentsPane&quot; Id=&quot;DocumentsPane&quot;&gt;
  
  &lt;dock:Document Id=&quot;WelcomeDoc&quot; Title=&quot;Welcome&quot; CanClose=&quot;false&quot;&gt;
    &lt;StackPanel Margin=&quot;10&quot;&gt;
      &lt;TextBlock Text=&quot;Welcome to the Application&quot; 
                 FontSize=&quot;18&quot; FontWeight=&quot;Bold&quot; Margin=&quot;0,0,0,10&quot;/&gt;
      &lt;TextBlock Text=&quot;This is a welcome document with static content.&quot;
                 TextWrapping=&quot;Wrap&quot;/&gt;
      &lt;Button Content=&quot;Get Started&quot; Margin=&quot;0,10,0,0&quot;/&gt;
    &lt;/StackPanel&gt;
  &lt;/dock:Document&gt;
  
  &lt;dock:Document Id=&quot;SettingsDoc&quot; Title=&quot;Settings&quot; CanClose=&quot;true&quot;&gt;
    &lt;ScrollViewer&gt;
      &lt;StackPanel Margin=&quot;10&quot;&gt;
        &lt;TextBlock Text=&quot;Application Settings&quot; FontWeight=&quot;Bold&quot; Margin=&quot;0,0,0,10&quot;/&gt;
        &lt;CheckBox Content=&quot;Enable notifications&quot; Margin=&quot;0,5&quot;/&gt;
        &lt;CheckBox Content=&quot;Auto-save documents&quot; Margin=&quot;0,5&quot;/&gt;
        &lt;CheckBox Content=&quot;Dark theme&quot; Margin=&quot;0,5&quot;/&gt;
      &lt;/StackPanel&gt;
    &lt;/ScrollViewer&gt;
  &lt;/dock:Document&gt;
  
&lt;/dock:DocumentDock&gt;
</code></pre>
<h2 id="working-with-tools">Working with Tools</h2>
<p>Tools work similarly to documents. Here's an example using MVVM base classes:</p>
<h3 id="tool-viewmodel">Tool ViewModel</h3>
<pre><code class="lang-csharp">using Dock.Model.Mvvm.Controls;

namespace YourApp.ViewModels.Tools;

public class PropertiesToolViewModel : Tool
{
    private object? _selectedObject;
    
    public PropertiesToolViewModel()
    {
        Id = &quot;PropertiesTool&quot;;
        Title = &quot;Properties&quot;;
        CanClose = false;
    }

    public object? SelectedObject
    {
        get =&gt; _selectedObject;
        set =&gt; SetProperty(ref _selectedObject, value);
    }
}
</code></pre>
<h3 id="tool-view">Tool View</h3>
<pre><code class="lang-xaml">&lt;!-- Views/Tools/PropertiesToolView.axaml --&gt;
&lt;UserControl xmlns=&quot;https://github.com/avaloniaui&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
             xmlns:vm=&quot;using:YourApp.ViewModels.Tools&quot;
             x:Class=&quot;YourApp.Views.Tools.PropertiesToolView&quot;
             x:DataType=&quot;vm:PropertiesToolViewModel&quot;&gt;

  &lt;Grid&gt;
    &lt;TextBlock Text=&quot;Properties Panel&quot; VerticalAlignment=&quot;Center&quot; 
               HorizontalAlignment=&quot;Center&quot; FontStyle=&quot;Italic&quot;
               IsVisible=&quot;{Binding SelectedObject, Converter={x:Static ObjectConverters.IsNull}}&quot;/&gt;
    
    &lt;ScrollViewer IsVisible=&quot;{Binding SelectedObject, Converter={x:Static ObjectConverters.IsNotNull}}&quot;&gt;
      &lt;StackPanel Margin=&quot;5&quot;&gt;
        &lt;TextBlock Text=&quot;Selected Object Properties&quot; FontWeight=&quot;Bold&quot; Margin=&quot;0,0,0,10&quot;/&gt;
        &lt;!-- Add property editors here --&gt;
      &lt;/StackPanel&gt;
    &lt;/ScrollViewer&gt;
  &lt;/Grid&gt;

&lt;/UserControl&gt;
</code></pre>
<h3 id="register-tool-datatemplate">Register Tool DataTemplate</h3>
<pre><code class="lang-xaml">&lt;Application.DataTemplates&gt;
  &lt;DataTemplate DataType=&quot;{x:Type vm:PropertiesToolViewModel}&quot;&gt;
    &lt;views:PropertiesToolView /&gt;
  &lt;/DataTemplate&gt;
&lt;/Application.DataTemplates&gt;
</code></pre>
<h2 id="common-issues-and-troubleshooting">Common Issues and Troubleshooting</h2>
<h3 id="issue-unexpected-content-error">Issue: &quot;Unexpected content&quot; Error</h3>
<p><strong>Problem</strong>: Getting <code>System.ArgumentException: &quot;Unexpected content ...&quot;</code> when adding documents.</p>
<p><strong>Cause</strong>: Setting <code>Content</code> to a view model or other unsupported object without a template. <code>Content</code> must be a <code>Control</code>, a template/function (<code>Func&lt;IServiceProvider, object&gt;</code>), or template content produced by XAML.</p>
<p><strong>Solution</strong>: Use one of the supported approaches above (Control/Function/DataTemplate).</p>
<pre><code class="lang-csharp">// ❌ Unsupported: view model instance without a template
var document = new Document
{
    Content = new MyViewModel()
};

// ✅ Use ViewModel + DataTemplate approach instead
var document = new MyDocumentViewModel();

// ✅ Or provide a Control or factory
var document = new Document
{
    Content = new Func&lt;IServiceProvider, object&gt;(_ =&gt; new MyUserControl())
};

// ✅ Direct Control assignment is valid
var document = new Document
{
    Content = new MyUserControl()
};
</code></pre>
<h3 id="issue-emptyblank-document-tabs-with-itemssource">Issue: Empty/Blank Document Tabs with ItemsSource</h3>
<p><strong>Problem</strong>: Document tabs show up but content is empty when using ItemsSource.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Ensure <code>DocumentTemplate</code> has proper <code>x:DataType=&quot;Document&quot;</code> on the root element</li>
<li>Access your model properties via <code>{Binding Context.PropertyName}</code> not <code>{Binding PropertyName}</code></li>
<li>Verify your model implements <code>INotifyPropertyChanged</code></li>
<li>Check that your collection items have the expected property names (Title, Name, etc.)</li>
</ol>
<p><strong>Example Fix</strong>:</p>
<pre><code class="lang-xaml">&lt;!-- ❌ Wrong DataType --&gt;
&lt;DocumentTemplate x:DataType=&quot;local:MyModel&quot;&gt;
  &lt;TextBlock Text=&quot;{Binding Title}&quot;/&gt;
&lt;/DocumentTemplate&gt;

&lt;!-- ✅ Correct DataType --&gt;
&lt;DocumentTemplate&gt;
  &lt;StackPanel x:DataType=&quot;Document&quot;&gt;
    &lt;TextBlock Text=&quot;{Binding Title}&quot;/&gt;
    &lt;TextBlock Text=&quot;{Binding Context.Content}&quot;/&gt;
  &lt;/StackPanel&gt;
&lt;/DocumentTemplate&gt;
</code></pre>
<h3 id="issue-compiled-binding-errors-for-context">Issue: Compiled binding errors for <code>Context.*</code></h3>
<p><strong>Problem</strong>: Build errors like &quot;Unable to resolve property or method ... on type 'Document'&quot; when using <code>{Binding Context.SomeProperty}</code>.</p>
<p><strong>Cause</strong>: <code>Document.Context</code> is typed <code>object?</code>, so compiled bindings cannot infer model properties from <code>Context</code>.</p>
<p><strong>Solution</strong>: Rebind a subtree to the model and set <code>x:DataType</code>, or cast in the binding path (or disable compiled bindings for that subtree).</p>
<pre><code class="lang-xaml">&lt;DocumentTemplate&gt;
  &lt;StackPanel x:DataType=&quot;Document&quot;&gt;
    &lt;StackPanel DataContext=&quot;{Binding Context}&quot;
                x:DataType=&quot;vm:MyDocumentModel&quot;&gt;
      &lt;TextBox Text=&quot;{Binding Content}&quot;/&gt;
    &lt;/StackPanel&gt;
  &lt;/StackPanel&gt;
&lt;/DocumentTemplate&gt;
</code></pre>
<h3 id="issue-emptyblank-document-tabs-with-datatemplates">Issue: Empty/Blank Document Tabs with DataTemplates</h3>
<p><strong>Problem</strong>: Document tabs show up but content is empty when using ViewModel approach.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Check that your DataTemplate is registered in <code>App.axaml</code></li>
<li>Verify the DataType in your DataTemplate matches your ViewModel type exactly</li>
<li>Ensure the view's <code>x:DataType</code> matches the ViewModel type</li>
<li>Check that the ViewModel namespace is correctly imported</li>
</ol>
<h3 id="issue-missing-dock-types-in-xaml">Issue: Missing Dock Types in XAML</h3>
<p><strong>Problem</strong>: <code>Unable to resolve type RootDock from namespace https://github.com/avaloniaui</code></p>
<p><strong>Solution</strong>: Add the <code>Dock.Model.Avalonia</code> package and namespace:</p>
<pre><code class="lang-xaml">xmlns:dock=&quot;using:Dock.Model.Avalonia.Controls&quot;
</code></pre>
<h3 id="issue-itemssource-documents-not-updating">Issue: ItemsSource Documents Not Updating</h3>
<p><strong>Problem</strong>: Changes to your model properties don't reflect in the document content.</p>
<p><strong>Solution</strong>: Ensure your model implements <code>INotifyPropertyChanged</code>:</p>
<pre><code class="lang-csharp">public class MyDocumentModel : INotifyPropertyChanged
{
    private string _title = &quot;&quot;;
    
    public string Title
    {
        get =&gt; _title;
        set =&gt; SetProperty(ref _title, value);
    }
    
    protected bool SetProperty&lt;T&gt;(ref T field, T value, [CallerMemberName] string propertyName = &quot;&quot;)
    {
        if (EqualityComparer&lt;T&gt;.Default.Equals(field, value)) return false;
        field = value;
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        return true;
    }
    
    public event PropertyChangedEventHandler? PropertyChanged;
}
</code></pre>
<h2 id="complete-examples">Complete Examples</h2>
<h3 id="file-manager-using-itemssource-recommended">File Manager using ItemsSource (Recommended)</h3>
<p>This example shows a complete file manager implementation using the ItemsSource approach:</p>
<pre><code class="lang-csharp">// File Model
public class FileDocument : INotifyPropertyChanged
{
    private string _title = &quot;&quot;;
    private string _content = &quot;&quot;;
    private string _filePath = &quot;&quot;;
    private bool _isModified;

    public string Title
    {
        get =&gt; _title;
        set =&gt; SetProperty(ref _title, value);
    }

    public string Content
    {
        get =&gt; _content;
        set 
        {
            if (SetProperty(ref _content, value))
            {
                IsModified = true;
            }
        }
    }

    public string FilePath
    {
        get =&gt; _filePath;
        set =&gt; SetProperty(ref _filePath, value);
    }

    public bool IsModified
    {
        get =&gt; _isModified;
        set =&gt; SetProperty(ref _isModified, value);
    }

    public bool CanClose =&gt; !IsModified || ConfirmClose();

    public ICommand SaveCommand { get; }
    public ICommand SaveAsCommand { get; }

    public FileDocument()
    {
        SaveCommand = new RelayCommand(Save, () =&gt; IsModified);
        SaveAsCommand = new RelayCommand(SaveAs);
    }

    private void Save()
    {
        // Save to FilePath
        File.WriteAllText(FilePath, Content);
        IsModified = false;
    }

    private void SaveAs()
    {
        // Show save dialog and save
    }

    private bool ConfirmClose()
    {
        // Show &quot;Save changes?&quot; dialog
        return true; // or false based on user choice
    }

    // INotifyPropertyChanged implementation...
}

// Main ViewModel
public class FileManagerViewModel : INotifyPropertyChanged
{
    public ObservableCollection&lt;FileDocument&gt; OpenFiles { get; } = new();

    public ICommand OpenFileCommand { get; }
    public ICommand NewFileCommand { get; }

    public FileManagerViewModel()
    {
        OpenFileCommand = new RelayCommand(OpenFile);
        NewFileCommand = new RelayCommand(NewFile);
    }

    private void NewFile()
    {
        OpenFiles.Add(new FileDocument
        {
            Title = $&quot;Untitled{OpenFiles.Count + 1}.txt&quot;,
            Content = &quot;&quot;,
            FilePath = &quot;&quot;
        });
    }

    private void OpenFile()
    {
        // Show file dialog and load file
        var filePath = ShowOpenFileDialog();
        if (!string.IsNullOrEmpty(filePath))
        {
            var content = File.ReadAllText(filePath);
            OpenFiles.Add(new FileDocument
            {
                Title = Path.GetFileName(filePath),
                Content = content,
                FilePath = filePath
            });
        }
    }
}
</code></pre>
<p><strong>XAML:</strong></p>
<pre><code class="lang-xaml">&lt;DockControl&gt;
  &lt;DockControl.Factory&gt;
    &lt;Factory /&gt;
  &lt;/DockControl.Factory&gt;
  
  &lt;RootDock&gt;
    &lt;DocumentDock ItemsSource=&quot;{Binding OpenFiles}&quot;&gt;
      &lt;DocumentDock.DocumentTemplate&gt;
        &lt;DocumentTemplate&gt;
          &lt;Grid RowDefinitions=&quot;Auto,*,Auto&quot; x:DataType=&quot;Document&quot;&gt;
            &lt;!-- File path header --&gt;
            &lt;TextBlock Grid.Row=&quot;0&quot; Text=&quot;{Binding Context.FilePath}&quot; 
                       FontSize=&quot;10&quot; Opacity=&quot;0.7&quot; Margin=&quot;5&quot;/&gt;
            
            &lt;!-- Main content editor --&gt;
            &lt;TextBox Grid.Row=&quot;1&quot; Text=&quot;{Binding Context.Content}&quot; 
                     AcceptsReturn=&quot;True&quot; AcceptsTab=&quot;True&quot;
                     FontFamily=&quot;Consolas&quot; Margin=&quot;5&quot;/&gt;
            
            &lt;!-- Action buttons --&gt;
            &lt;StackPanel Grid.Row=&quot;2&quot; Orientation=&quot;Horizontal&quot; 
                        HorizontalAlignment=&quot;Right&quot; Margin=&quot;5&quot;&gt;
              &lt;Button Content=&quot;Save&quot; Command=&quot;{Binding Context.SaveCommand}&quot;
                      IsEnabled=&quot;{Binding Context.IsModified}&quot;/&gt;
              &lt;Button Content=&quot;Save As&quot; Command=&quot;{Binding Context.SaveAsCommand}&quot;
                      Margin=&quot;5,0,0,0&quot;/&gt;
            &lt;/StackPanel&gt;
          &lt;/Grid&gt;
        &lt;/DocumentTemplate&gt;
      &lt;/DocumentDock.DocumentTemplate&gt;
    &lt;/DocumentDock&gt;
  &lt;/RootDock&gt;
&lt;/DockControl&gt;
</code></pre>
<h3 id="simple-text-editor-document-viewmodel-approach">Simple Text Editor Document (ViewModel Approach)</h3>
<pre><code class="lang-csharp">// ViewModel
public class TextEditorViewModel : Document
{
    private string _content = &quot;&quot;;
    private bool _isModified;

    public string Content
    {
        get =&gt; _content;
        set 
        { 
            if (SetProperty(ref _content, value))
            {
                IsModified = true;
                OnPropertyChanged(nameof(DisplayTitle));
            }
        }
    }

    public bool IsModified
    {
        get =&gt; _isModified;
        set =&gt; SetProperty(ref _isModified, value);
    }

    public string DisplayTitle =&gt; IsModified ? $&quot;{Title}*&quot; : Title;

    public void Save()
    {
        // Save logic here
        IsModified = false;
        OnPropertyChanged(nameof(DisplayTitle));
    }
}
</code></pre>
<h3 id="properties-tool-with-object-inspector">Properties Tool with Object Inspector</h3>
<pre><code class="lang-csharp">// Tool ViewModel
public class ObjectInspectorViewModel : Tool
{
    private object? _target;
    private PropertyInfo[]? _properties;

    public object? Target
    {
        get =&gt; _target;
        set
        {
            if (SetProperty(ref _target, value))
            {
                Properties = value?.GetType().GetProperties();
            }
        }
    }

    public PropertyInfo[]? Properties
    {
        get =&gt; _properties;
        set =&gt; SetProperty(ref _properties, value);
    }
}
</code></pre>
<p>This comprehensive guide should help users understand how to properly work with document and tool content in the Dock framework, with the new ItemsSource functionality providing the most streamlined approach for most scenarios.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/wieslawsoltes/Dock/blob/master/docfx/articles/dock-content-guide.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
